# -*- coding: utf-8 -*-
"""experimentalLipschitzConstant.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hih82l8py-EYuz8TiCyLl9BPreQC35j8
"""

import torch
import torchvision
import torchvision.transforms as transforms
import torch.nn as nn
import numpy as np
import random
import matplotlib.pyplot as plt

def approxLipschitzExperimental(net,X,device='cuda'):
  images = X.to(device)
  LLL = len(images)
  times = 10
  #randImages = torch.rand(LLL,3,32,32).to(device)
  lip = 0
  for l in range(LLL):
      X = images[l:l+1]
      for i in range(times):
        #create a perturbation of bounded norm (1,10)
        pert = torch.rand(1,3,32,32).to(device)
        pert /= torch.norm(pert)
        pert *= random.randint(1,10)
        #perturbed image
        Y = X + pert
        temp = (torch.linalg.norm(net(X)-net(Y))/torch.linalg.norm(X-Y,dim=(1,2,3))).item()
        if temp>lip:
            lip=temp
  
  return lip
  
def approxLipschitz(g,shape,times,initial,device='cuda'):
    v = initial
    v = v.requires_grad_()
    v = v/torch.norm(v)
    for k in range(times):
        v = v.requires_grad_()
        func = 0.5 * torch.norm(g(v))**2
        v = torch.autograd.grad(func,v)[0]
        sigma = torch.sqrt(torch.norm(v))
        v = v/torch.norm(v,2)
    return v,sigma